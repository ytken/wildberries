# Многопоточность, Flow
## Как работает Flow под капотом? В каких случаях его удобно использовать?
Flow работает на основе корутин (является частью kotlinx.coroutines) и представляет возможность обработать результат долгой операции по частям (элементам) не дожидаясь полной отработки. Таким образом, отдавая suspend функцию во flow, мы можем вызвать полученную функцию и подписаться на ее результаты в контексте корутин. Действия, которые необходимо провести с результатом, записываются в блоке collect { }, при вызове которого и начинает работать flow. Такой тип flow называется холодным, в отличие от горячего, который работает всегда, независимо от подписчиков.
В работу Flow вовлечены три объекта:
1. Producer — производит (создает, испускает) данные в виде потока. Данные передаются в отдельном потоке благодаря корутинам.
2. Intermediary (Посредник) — класс или классы, которые могут модифицировать или изменять данные, произведенные Producer’ом. Наличие посредников не обязательно, если данные не нужно модифицировать или переводить их из одного типа в другой.
3. Consumer — получатель данных, произведённых Producer’ом.
Flow имеет лучшую производительность по сравнению с RxJava. Таким образом, он идеально подходит для асинхронной последовательной обработки простых данных.
